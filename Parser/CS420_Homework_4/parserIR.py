"""
Parser Intermediate Representation (PIR) for Eck Compiler
Dr. Hilton
CS420, Spring 2020

This module defines a set of classes that form the Intermediate Representation
generated by the parser.  The IR is an Abstract Syntax Tree (AST)
representation of Eck that closely follows the structure of the BNF
description of Eck.
"""


class PIR_Base:
    """Base class for the Parser Intermediate Representation"""

    def __init__(self, line):
        # line number in the source code for the start of this syntax element
        self.lineNumber = line


class PIR_AssignmentStatement(PIR_Base):
    """<assignmentStatement> AST"""

    def __init__(self, line, variable, arrayExp, expression):
        """
        line            line number where assignment occurs
        variable        string; name of variable identifier
        arrayExp        PIR object for array index expression, or None
        expression      PIR object for expression being assigned to variable
        """
        super().__init__(line)
        self.arrayExpression = arrayExp
        self.expression = expression
        self.variable = variable


class PIR_Class(PIR_Base):
    """<classDec> AST"""

    def __init__(self, line, name, varList, subroutineList):
        """
        line            line number where class definition starts
        name            string; name of the class
        varList         list of PIR_VariableDeclaration objects
        subroutineList  list of PIR_SubroutineDeclaration objects
        """
        super().__init__(line)
        self.name = name
        self.subroutines = subroutineList
        self.variables = varList


class PIR_DoStatement(PIR_Base):
    """<doStatement> AST"""

    def __init__(self, line, subOrMethod):
        """
        line             Line number where do statement begins
        subOrMethod      Either a PIR_SubroutineCall or PIR_MethodCall object
        """
        super().__init__(line)
        self.subprogram = subOrMethod


class PIR_ExpressionBinop(PIR_Base):
    """AST for binary operator expressions, used by the following rules:
    <expression>, <exp1>, <exp2>, <exp3>
    """

    def __init__(self, line, op, leftExp, rightExp):
        """
        line        Line number where expression begins
        op          Lexeme enumerated constant representing the binary op
        leftExp     PIR object for the left operand
        rightExp    PIR object for the right operand
        """
        super().__init__(line)
        self.leftExp = leftExp
        self.operator = op
        self.rightExp = rightExp


class PIR_ExpressionConstant(PIR_Base):
    """AST for integer, string, boolean, and keyword constants used by
    rule <exp4>"""

    def __init__(self, line, typ, value):
        """
        line    Line number where expression begins
        typ     (Lexeme enumerated constant representing type of constant, None | "String")
        value   Python representation of the constant's value:
                a Python int for Lexeme.INTEGER_CONST
                a Python string for Lexeme.STRING_CONST
                True for Lexeme.KW_TRUE
                False for Lexeme.KW_FALSE
                None for Lexeme.NULL and Lexeme.THIS
        """
        super().__init__(line)
        self.type = typ
        self.value = value


class PIR_ExpressionUnop(PIR_Base):
    """AST for unary expressions used in rule <exp4>"""

    def __init__(self, line, op, expr):
        """
        line        Line number where expression begins
        op          Lexeme enumerated constant representing the unary operation
        expr        PIR object for the operand
        """
        super().__init__(line)
        self.expression = expr
        self.operator = op


class PIR_ExpressionVariable(PIR_Base):
    """AST representation of a variable expression used in rule <exp4>"""

    def __init__(self, line, name, aryExpr=None):
        """
        line        Line number where expression begins
        name        string; name of variable
        aryExpr     Optional; If the variable is an array, it is the
                    PIR object for the array indexing expression
        """
        super().__init__(line)
        self.arrayExpression = aryExpr
        self.name = name


class PIR_IfStatement(PIR_Base):
    """AST combining the <ifStatement> and <elseStatement> rules."""

    def __init__(self, line, condExp, thenExp, elseExp=None):
        """
        line        Line number where if begins
        condExp     PIR object for the conditional expression
        thenExp     PIR object for the true branch expression
        elseExp     Optional; PIR object for the false branch expression
        """
        super().__init__(line)
        self.condition = condExp
        self.elseBranch = elseExp
        self.thenBranch = thenExp


class PIR_None:
    """This is an aid for program development.  If you have not
    implemented a parsing method yet, you can always return an
    object of this type from your method stub."""

    def write(self, ioStream, indentation=0):
        indent = " " * indentation
        ioStream.write(f"{indent}None\n")


class PIR_ReturnStatement(PIR_Base):
    """AST for rules <returnStatement> and <returnStatement1>"""

    def __init__(self, line, expr=None):
        """
        line    Line number where return statement appears
        expr    Optional; PIR object for the return value, if there
                is one
        """
        super().__init__(line)
        self.expression = expr


class PIR_SubroutineBody(PIR_Base):
    """<subroutineBody> AST"""

    def __init__(self, line, varList, statementList):
        """
        line            Line number for start of subroutine
        varList         List of PIR_VariableDeclaration objects
        statementList   List of PIR objects for the body's statements
        """
        super().__init__(line)
        self.statements = statementList
        self.variables = varList


class PIR_SubroutineCall(PIR_Base):
    """AST for subroutine calls, used in rules:
    < doStatement > , <doStatement1 > , <exp4 > , <exp4Id > """

    def __init__(self, line, varOrClass, subName, exprList):
        """
        line            Line number where call appears
        varOrClass      string; for functions and constructors, class name
                            for methods, variable name or None
        subName         string; name of subroutine to call
        exprList        list of PIR expression objects for the
                        actual parameters of the call
        """
        super().__init__(line)
        self.actualParameters = exprList
        self.mangledSubrName = None         # assigned by the Type Checker; mangled name of subroutine to call
        self.subroutineName = subName
        self.varOrClass = varOrClass


class PIR_SubroutineDeclaration(PIR_Base):
    """<subroutineDec> AST"""

    def __init__(self, line, specifier, typ, name, paramList, body):
        """
        line            Line number where subroutine declaration begins
        specifier       SubroutineSpecifiers enumerated type constant
        typ             (DataType, className | None) pair containing return type
        name            string; name of the subroutine being defined
        paramList       list of PIR_VariableDeclaration objects
        body            PIR_SubroutineBody object
        """
        super().__init__(line)
        self.body = body
        self.mangledName = None     # assigned by the SymbolTableManager
        self.name = name
        self.parameters = paramList
        self.returnFound = False    # assigned by the Type Checker
        self.specifier = specifier
        self.type = typ


class PIR_VariableDeclaration(PIR_Base):
    """AST for variable declarations used in <parameterList> and
    <subroutineBody>"""

    def __init__(self, line, typ, name, scope):
        """
        line    Line number where variable is declared
        typ     (DataType, className | None) pair containing variable type
        name    string; name of variable being declared
        scope   VariableScopes constant
        """
        super().__init__(line)
        self.name = name
        self.scope = scope
        self.type = typ


class PIR_WhileStatement(PIR_Base):
    """<whileStatement> AST"""

    def __init__(self, line, condExp, statementList):
        """
        line                Line number where while statement starts
        condExp             PIR expression object for while condition
        statementList       list of PIR statement objects
        """
        super().__init__(line)
        self.condition = condExp
        self.statements = statementList
